# 显示部分功能描述

## 端口和变量描述

![61e4e97aaea4c2af10bd114e13e3ee2](C:\Users\TANGXI~1\AppData\Local\Temp\WeChat Files\61e4e97aaea4c2af10bd114e13e3ee2.png)

 显示模块顶层的**输入变量**组成为：

2bit的rst：用于选择显示的子模块；

1bit的clk：即开发板Y18所带的时钟信号；

4bit的 left \ start \ each \ id1 \ id0 \ remain1\ remain0 ：分别为显示的剩余车辆、起始价、时价、会员帐号的第0位、会员帐号的第1位、余额的第1位、余额的第0位；

6bit的 x7 \ x6 \ x5 \ x4 \ x3 \ x2 \ x1 \ x0：分别为静态显示时从左到右每一个七段数码显示管应该显示的字符的编码。

 显示模块顶层的**输出变量**组成为：

8bit的DIG：通过自己的编码控制8个七段数码显示管的亮暗；

8bit 的Y：通过自己的编码控制七段数码显示管显示什么字符。

显示模块顶层的**其他变量**组成为：

1bit的寄存器 rst_tmp1\ rst_tmp2 \ rst_tmp3：分别作为三个子模块的reset信号；

8bit的线网 DIG1 \ DIG2 \ DIG3 ：分别接受三个子模块的DIG输出 ， 同样为控制8个七段数码显示管亮暗的变量；

8bit的线网 Y1 \ Y2 \ Y3 ：分别接受三个子模块的Y输出， 同样为控制七段数码管显示什么字符的变量。

## 功能实现

#### 1.例化

```verilog
flowinglight u1(rst_tmp1,clk,DIG1,Y1,left,start,each);
flowinglight_vip u2(rst_tmp2,clk,DIG2,Y2,id1,id0,remain1,remain0);
static_light u3(rst_tmp3,clk,DIG3,Y3,x7,x6,x5,x4,x3,x2,x1,x0);
```

#### 2.模块选择

根据顶层rst的不同，将有效的rst_tmp赋为1，其余为0。顶层DIG\Y取有效模块传上来的对应线网。

```verilog
always@*
begin
if(rst == 2'b01)
   begin 
     rst_tmp1=1;
     rst_tmp2=0;
     rst_tmp3=0;
     DIG=DIG1;
     Y=Y1;
   end
 else if(rst==2'b10)
    begin         
      rst_tmp1=0;   
      rst_tmp2=1;   
      rst_tmp3=0; 
      DIG=DIG2;
      Y=Y2;  
    end
 else if(rst==2'b11) 
    begin            
      rst_tmp1=0;    
      rst_tmp2=0;          
      rst_tmp3=1;  
      DIG=DIG3;
      Y=Y3;        
    end                    
 else     
    begin        
      rst_tmp1=0;
      rst_tmp2=0;
      rst_tmp3=0;  
      DIG=8'b1111_1111;
      Y=8'b1111_1111;                                                                 end                 
end
endmodule
```

## 子模块描述

由于之后的滚动显示是在静态显示的基础上实现的，因此先描述静态显示模块

#### 1. static_light 静态显示模块

##### 端口及变量描述

![image-20211231120152080](C:\Users\TANGXINYU\AppData\Roaming\Typora\typora-user-images\image-20211231120152080.png)

该模块输入包括reset信号rst，时钟信号clk，控制8个七段数码显示管显示内容的8个6bit的 x0_in、x1_in、x2_in、x3_in、x4_in、x5_in、x6_in,、x7_in。

输出包括顶层提到过的控制七段数码显示管的两个8bit变量：DIG和Y。

其他变量还有：

寄存器：分过频的时钟信号clkout，32bit的分频时使用的计数器cnt， 5bit 的scan_cnt标记显示哪个七段数码显示管，7bit的x7, x6, x5, x4, x3, x2, x1记录显示字符的编码，使高电平有效的8bit的DIG_r, 使高电平有效且小数点不显示的8bit的Y_r。

参数period，用于分频。

##### 功能实现

① 由于七段数码显示管低电平有效，且我们不需要小数点的显示，为了编码方便

```verilog
 assign Y= {1'b1,(~Y_r[6:0])};
 assign DIG= ~DIG_r;
```

②period=200000，将时钟分频为500Hz，用作之后七段数码显示管交替亮暗的频率（即敏感信号）

```verilog
always @(posedge clk or negedge rst)
 begin
   if(!rst) begin
     cnt<=0;
     clkout<=0;
   end
   else begin
      if(cnt == (period>>1)-1)
      begin
       clkout<=~clkout;
       cnt<=0;
   end
   else
     cnt<=cnt+1;
  end
 end
```

③通过改变DIG_r 让8个七段数码显示管按频率依次亮起，并用scan_cnt记录亮的是哪个七段数码显示管，由于频率较高，达到人眼看起来全亮的状态。

```verilog
always @ (posedge clkout or negedge rst)
begin
 if(!rst)
   scan_cnt<=0;
 else begin
   scan_cnt <= scan_cnt + 1;
   if(scan_cnt == 3'd7) scan_cnt <= 0;  
 end
end

always @ (scan_cnt)
begin
  case(scan_cnt)
    3'b000: DIG_r=8'b0000_0001;
    3'b001: DIG_r=8'b0000_0010;
    3'b010: DIG_r=8'b0000_0100;
    3'b011: DIG_r=8'b0000_1000;
    3'b100: DIG_r=8'b0001_0000;
    3'b101: DIG_r=8'b0010_0000;
    3'b110: DIG_r=8'b0100_0000;
    3'b111: DIG_r=8'b1000_0000;
    default: DIG_r = 8'b0000_0000;
    endcase
end
```

④在不同显示管亮起时，通过改变Y_r的编码让七段数码显示管显示不同的值，达到八个七段数码显示管分别显示不同值的效果

```verilog
always @ (scan_cnt)
begin
 case(scan_cnt)
  0:Y_r= x0;
  1:Y_r= x1;
  2:Y_r= x2;
  3:Y_r= x3;
  4:Y_r= x4;
  5:Y_r= x5;
  6:Y_r= x6;
  7:Y_r= x7;
  default : Y_r= 7'b0000000;
  endcase
 end
endmodule
```

#### 2. flowinglight 闲置界面滚动显示 & flowinglight_vip 会员界面滚动显示模块

##### 端口及变量描述

① 在flowinglight中

![image-20211231120027928](C:\Users\TANGXINYU\AppData\Roaming\Typora\typora-user-images\image-20211231120027928.png)

输入包括reset信号，时钟信号clk，4bit的剩余车辆显示数目、起步价显示数目、时价显示数目。

输出包括顶层提到过的控制七段数码显示管的两个8bit变量：DIG和Y。

其他变量：

寄存器：分过频的时钟信号clkout，以及分频时用到的计数器32bit的cnt，用于达到静态显示的目的；

另外一个分过频的时钟信号clk_out，以及用到的计数器32bit的cnt_flow，使8个七段数码管的显示按这个频率切换，达到滚动显示的目的；

5bit 的scan_cnt标记显示哪个七段数码显示管；

7bit的left_flow、start_flow、each_flow为根据剩余车位、起步价、时价的值，对应七段数码显示管显示时的编码；

7bit的x7、x6、x5、x4、x3、x2、x1、x0作为变量，记录滚动时每个七段数码显示管的状态迁移。

4bit的jugde变量，用来记录现在滚动到什么状态；

使高电平有效的8bit的DIG_r；使高电平有效且小数点不显示的8bit的Y_r；

参数period、period_flow，分别用于两个分频；

② 在flowinglight_vip中

![image-20211231115917451](C:\Users\TANGXINYU\AppData\Roaming\Typora\typora-user-images\image-20211231115917451.png)

输入除了显示的参数变为4bit的会员帐号第0位id0、会员帐号第1位id1、余额第0位remain0、余额第1位remain1，其余均与滚动显示闲置状态的输入相同，分别为rst、clk。

输出也为DIG、Y不变。

其他变量：

寄存器：除了用于记录显示的数的编码的变量变为id0_flow、id1_flow、remain_0、remain_1，其余均不变，分别为clkout、cnt、clk_flow、cnt_flow、scan_cnt、x7、x6、x5、x4、x3、x2、x1、x0、jugde、DIG_r、Y_r。

参数仍然为period、period_flow不变。

##### 功能实现

由于两个滚动显示基本相同，核心代码及描述只选择一个模块说明。

在静态显示的基础上，滚动显示还有以下行为：

① period_flow=100000000，频率为1Hz，用于控制滚动显示状态改变的频率，是人演可以分辩的状态。

```verilog
  always @(posedge clk or negedge rst)
 begin
   if(!rst) begin
     cnt_flow<=0;
     clkout_flow<=0;
   end
   else begin
      if(cnt_flow == (period_flow>>1)-1)
      begin
       clkout_flow<=~clkout_flow;
       cnt_flow<=0;
   end
   else
     cnt_flow<=cnt_flow+1;
  end
 end
```

② 敏感与分频后的clk_flow，以这个频率使x7、x6、x5、x4、x3、x2、x1、x0相比静态显示时，成为了变量，不同状态的编码不同。

```verilog
always @(posedge clkout_flow or negedge rst)
begin
    if(!rst) 
    begin
     x0<= 7'b0000000;
     x1 <=7'b0000000;
     x2 <=7'b0000000;
     x3 <=7'b0000000;
     x4 <=7'b0000000;
     x5 <=7'b0000000;
     x6 <=7'b0000000;
     x7 <=7'b0000000; 
     judge<=0;
     end
    else begin
      if(judge==4'd0) begin
                      x0 <=7'b0111000;//L
                      x1 <=7'b0000000;
                      x2 <=7'b0000000;
                      x3 <=7'b0000000;
                      x4 <=7'b0000000;
                      x5 <=7'b0000000;
                      x6 <=7'b0000000;
                      x7 <=7'b0000000;
                      judge  <= judge+1; 
                      end
     else  if(judge==4'd1) begin
                       x0 <= left_flow;
                       x1 <=7'b0111000; //L
                       x2 <=7'b0000000;
                       x3 <=7'b0000000;
                       x4 <=7'b0000000;
                       x5 <=7'b0000000;
                       x6 <=7'b0000000;
                       x7 <=7'b0000000;
                       judge  <= judge+1; 
                       end
     ......
        
else if(judge==4'd15)  begin
                    x0 <=7'b0111000; //L
                    x1 <=7'b0000000; 
                    x2 <=7'b0000000; 
                    x3 <=7'b0000000; 
                    x4 <=7'b0000000; 
                    x5 <=7'b0000000; 
                    x6 <=7'b0000000; 
                    x7 <=7'b0000000; 
                    judge<=0;
                    end 
             
     end
end
```



# 键盘输入部分功能描述

## 端口及变量描述

![8cda8d4e6cc2c2adaa3c7c55b8df97f](C:\Users\TANGXI~1\AppData\Local\Temp\WeChat Files\8cda8d4e6cc2c2adaa3c7c55b8df97f.png)

键盘输入部分的**输入变量**有：

reset信号rst、时钟信号clk、控制输入几位数的3bit信号cnt_tmp、用于键盘上行扫描的4bit信号row。

键盘部分的**输出变量**有：

用于键盘上列扫描的4bit信号col、检测输入结束的寄存器finish、储存输入字符的30bit寄存器result、

其他变量：

线网：

子模块返回监测到的按下的6bit字符信号key_val，子模块返回的监测到的按下信号key_pressed_flag，子模块返回的分频后的时钟信号key_clk。

寄存器：

除抖后真正有效的按下信号flag，除抖时使用的计数器20bit的count，存输入位数的2bit的cnt；

该模块中还存在测试是用于显示的变量，由于整体功能实现并没有使用，这里不做描述

## 功能实现

#### 1.子模块例化

```verilog
    key_top key(clk,rst,row,col,key_val,key_clk,key_pressed_flag);
```

#### 2. 功能实现

①对子模块传递上来的key_pressed_flag信号进行除抖。

```verilog
    always@(posedge key_clk )
    begin
           if(key_pressed_flag)
           count=count+1;
           
           if(count== 20'd20)
           begin
               flag=1;
               count=20'd0;
               end
               else 
               flag=0;
   end
```

② 当检测到有效的按下信号时，先判断输入是否结束，若未结束则在判断按下的值之后对储存结果的寄存器result先赋值后移位，计数减一。同时当reset信号生效时给各个变量赋初值。

```verilog
 always@(posedge key_clk or posedge rst) 
    if(rst)
    begin
     cnt=cnt_tmp;
     finish=0;
     result=30'b111111_111111_111111_111111_111111;
     display_rst=2'b11;
    end
    else
      begin
        if(cnt==3'd0)
          begin       
          finish=1;  
          end        
        else
        if(flag)
          begin
            finish=0;
            case(key_val)
             6'h0:begin                                   
                  result[29:24]=6'b000_000;                 
                  result={ result[23:0], result[29:24] };
                   cnt=cnt-1'b1;   
                 end                                
             6'h1:begin                                    
                  result[29:24]=6'b000_001;                 
                  result={ result[23:0], result[29:24] };  
                   cnt=cnt-1'b1;            
                  end                                     
             6'h2:begin                                    
                  result[29:24]=6'b000_010;                 
                  result={ result[23:0], result[29:24] }; 
                   cnt=cnt-1'b1;   
                  end       
            ......
            endcase                  
          end   
       end
```

## 子模块描述

#### 1. key_top 单个键盘输入模块

##### 端口及变量描述

![image-20211231132603488](C:\Users\TANGXINYU\AppData\Roaming\Typora\typora-user-images\image-20211231132603488.png)

输入包括时钟信号clk、reset信号rst、用于键盘上行扫描的4bit信号row。

输出包括用于键盘上列扫描的4bit信号col、记录按下值的6bit寄存器keyboard_val、分过频的时钟信号key_clk、检测按下键盘的信号key_pressed_flag。

其他变量：

寄存器：

用于分频计数的20bit的cnt，记录现态和次态的6bit的current_state和next_state，用于锁存行值和列值的4bit的col_val和row_val。

参数：

NO_KEY_PRESSED = 6'b000_001;  // 没有按键按下  
SCAN_COL0      = 6'b000_010;  // 扫描第0列   
SCAN_COL1      = 6'b000_100;  // 扫描第1列   
SCAN_COL2      = 6'b001_000;  // 扫描第2列   
SCAN_COL3      = 6'b010_000;  // 扫描第3列   
KEY_PRESSED    = 6'b100_000;  // 有按键按下   

用于描述不同状态。

##### 功能实现

① 对原来时钟信号进行分频，降低为21ms监测一次

```verilog
always @ (posedge clk or posedge rst)
  if (rst )
    cnt <= 0;
  else 
    cnt <= cnt + 1'b1;
    
assign key_clk = cnt[19];    
```

②根据分好的频率进行状态切换

```verilog
always @ (posedge key_clk or posedge rst)
  if (rst)
    current_state <= NO_KEY_PRESSED;
  else
    current_state <= next_state;
```

③在状态变化时，根据当前状态以及键盘扫描情况进行状态转移

```verilog
always @ (*)
  case (current_state)
    NO_KEY_PRESSED :                    // 没有按键按下
        if (row != 4'hF)
          next_state = SCAN_COL0;
        else
          next_state = NO_KEY_PRESSED;
    SCAN_COL0 :                         // 扫描第0列 
        if (row != 4'hF)
          next_state = KEY_PRESSED;
        else
          next_state = SCAN_COL1;
    SCAN_COL1 :                         // 扫描第1列 
        if (row != 4'hF)
          next_state = KEY_PRESSED;
        else
          next_state = SCAN_COL2;    
    SCAN_COL2 :                         // 扫描第2列
        if (row != 4'hF)
          next_state = KEY_PRESSED;
        else
          next_state = SCAN_COL3;
    SCAN_COL3 :                         // 扫描第3列
        if (row != 4'hF)
          next_state = KEY_PRESSED;
        else
          next_state = NO_KEY_PRESSED;
    KEY_PRESSED :                       // 有按键按下
        if (row != 4'hF)
          next_state = KEY_PRESSED;
        else
          next_state = NO_KEY_PRESSED;                      
  endcase
 
```

④敏感于分频后的时钟信号，根据次态，给相应寄存器赋值，锁定行值和列值

```verilog
always @ (posedge key_clk or posedge rst)
  if (rst)
  begin
    col              <= 4'h0;
    key_pressed_flag <=    0;
  end
  else
    case (next_state)
      NO_KEY_PRESSED :                  // 没有按键按下
      begin
        col              <= 4'h0;
        key_pressed_flag <=    0;       // 清键盘按下标志
      end
      SCAN_COL0 :                       // 扫描第0列
        col <= 4'b1110;
      SCAN_COL1 :                       // 扫描第1列
        col <= 4'b1101;
      SCAN_COL2 :                       // 扫描第2列
        col <= 4'b1011;
      SCAN_COL3 :                       // 扫描第3列
        col <= 4'b0111;
      KEY_PRESSED :                     // 有按键按下
      begin
        col_val          <= col;        // 锁存列值
        row_val          <= row;        // 锁存行值
        key_pressed_flag <= 1;          // 置键盘按下标志  
      end
endcase
```

⑤在分频后的时钟的扫描状态下，根据锁定的行值和列值，确定按下的按键的值

```verilog
always @ (posedge key_clk or posedge rst)
  if (rst)
    keyboard_val <= 6'b111_111;
  else
    if (key_pressed_flag)
      case ({col_val, row_val})
        8'b1110_1110 : keyboard_val <=6'h1;
        8'b1110_1101 : keyboard_val <=6'h4;
        8'b1110_1011 : keyboard_val <=6'h7;
        8'b1110_0111 : keyboard_val <=6'hE;
                                      
        8'b1101_1110 : keyboard_val <=6'h2;
        8'b1101_1101 : keyboard_val <=6'h5;
        8'b1101_1011 : keyboard_val <=6'h8;
        8'b1101_0111 : keyboard_val <=6'h0;
                                      
        8'b1011_1110 : keyboard_val <=6'h3;
        8'b1011_1101 : keyboard_val <=6'h6;
        8'b1011_1011 : keyboard_val <=6'h9;
        8'b1011_0111 : keyboard_val <=6'hF;
                                      
        8'b0111_1110 : keyboard_val <=6'hA; 
        8'b0111_1101 : keyboard_val <=6'hB;
        8'b0111_1011 : keyboard_val <=6'hC;
        8'b0111_0111 : keyboard_val <=6'hD;  
        default:   keyboard_val <= 6'b111111;     
      endcase
     else  keyboard_val <= 6'b111111;
```

